#include <bits/stdc++.h>
using namespace std;

template <typename T>
struct Point {
  T x, y;
  auto operator<=>(const Point<T>&) const = default;
  Point operator-(const Point& other) const { return {x - other.x, y - other.y}; }
  T dot(const Point& other) const { return x * other.x + y * other.y; }
  T cross(const Point& other) const { return x * other.y - y * other.x; }
  T ccw(const Point<T>& b, const Point<T>& c) const { return (b - *this).cross(c - *this); }
  T norm2() const { return x * x + y * y; }
  T dist2(const Point<T>& other) const { return (*this - other).norm2(); }
  long double dist(const Point<T>& other) const { return sqrt(dist2(other)); }
};

template <typename T>
vector<Point<T>> convex_hull(vector<Point<T>> points) {
  if (points.size() <= 2) return points;

  ranges::sort(points);

  vector<Point<T>> lower, upper;
  for (const auto& p : points) {
    while (lower.size() >= 2 && end(lower)[-2].ccw(lower.back(), p) <= 0) lower.pop_back();
    lower.push_back(p);
  }
  for (const auto& p : views::reverse(points)) {
    while (upper.size() >= 2 && end(upper)[-2].ccw(upper.back(), p) <= 0) upper.pop_back();
    upper.push_back(p);
  }

  lower.pop_back();
  lower.insert(lower.end(), upper.begin(), upper.end() - 1);

  return lower;
}

struct Tree {
  Point<long long> p;
  int v, l;
};

int main() {
  cin.tie(nullptr)->sync_with_stdio(false);

  int n;
  while (cin >> n && n != 0) {
    vector<Tree> trees(n);
    for (int i : views::iota(0, n)) cin >> trees[i].p.x >> trees[i].p.y >> trees[i].v >> trees[i].l;

    int min_lost_value = 2e9;
    for (int mask : views::iota(0, 1 << n)) {
      int cut_val = 0, cut_len = 0;
      vector<Point<long long>> rem;

      for (int i : views::iota(0, n)) {
        if (!(mask & (1 << i))) {
          cut_val += trees[i].v;
          cut_len += trees[i].l;
        } else {
          rem.push_back(trees[i].p);
        }
      }

      if (cut_val >= min_lost_value) continue;
      double len = 0;
      if (rem.size() == 2) {
        len = 2.0 * rem[0].dist(rem[1]);
      } else if (rem.size() > 2) {
        auto hull = convex_hull(rem);
        for (size_t i : views::iota(0uz, hull.size())) len += hull[i].dist(hull[(i + 1) % hull.size()]);
      }

      if (cut_len >= len - 1e-9) min_lost_value = cut_val;
    }

    cout << "The lost value is " << min_lost_value << ".\n";
  }

  return 0;
}