#include <bits/stdc++.h>
using namespace std;
const long long INF = 1e18;

template <typename T>
struct Point {
  T x, y;
  auto operator<=>(const Point<T>&) const = default;
  Point operator-(const Point& other) const { return {x - other.x, y - other.y}; }
  T cross(const Point& other) const { return x * other.y - y * other.x; }
  T ccw(const Point<T>& b, const Point<T>& c) const { return (b - *this).cross(c - *this); }
};

struct Edge {
  Point<long long> u, v;
  int cost, id;
};

auto floyd_warshall(auto& graph) {
  for (int k = 1; k < graph.size(); k++) {
    for (int i = 1; i < graph.size(); i++) {
      for (int j = 1; j < graph.size(); j++) {
        if (graph[i][k] != INF && graph[k][j] != INF) graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
      }
    }
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  
  int N;
  long long X, Y;
  cin >> N >> X >> Y;
  
  Point<long long> waste = {X, Y};
  vector<Edge> valid;
  
  for (int i = 0; i < N; i++) {
    long long x1, y1, x2, y2;
    int c;
    cin >> x1 >> y1 >> x2 >> y2 >> c;
    
    Point<long long> p1 = {x1, y1}, p2 = {x2, y2};
    if (p1.ccw(p2, waste) > 0) valid.push_back({p1, p2, c, i});
    if (p2.ccw(p1, waste) > 0) valid.push_back({p2, p1, c, i});
  }
  
  int M = valid.size();
  vector<vector<long long>> graph(M + 1, vector<long long>(M + 1, INF));
  for (int i = 0; i < M; i++) {
    for (int j = 0; j < M; j++) {
      if (valid[i].v == valid[j].u) {
        if (valid[i].u.ccw(valid[i].v, valid[j].v) >= 0) graph[i + 1][j + 1] = valid[j].cost;
      }
    }
  }
  
  floyd_warshall(graph);
  
  long long min_cost = INF;
  for (int i = 1; i <= M; i++) {
    if (graph[i][i] != INF) min_cost = min(min_cost, graph[i][i]);
  }
  
  if (min_cost == INF) cout << -1 << "\n";
  else cout << min_cost << "\n";

  return 0;
}