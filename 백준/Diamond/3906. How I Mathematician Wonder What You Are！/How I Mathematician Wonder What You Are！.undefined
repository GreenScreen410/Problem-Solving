#include <bits/stdc++.h>
using namespace std;
const long double EPS = 1e-9;

struct Point {
  long double x, y;
  Point operator+(const Point& o) const { return {x + o.x, y + o.y}; }
  Point operator-(const Point& o) const { return {x - o.x, y - o.y}; }
  Point operator*(long double k) const { return {x * k, y * k}; }
  long double cross(const Point& o) const { return x * o.y - y * o.x; }
};

struct Line {
  Point p, dir;
  long double angle;
  Line(Point p, Point dir) : p(p), dir(dir) { angle = atan2(dir.y, dir.x); }
  bool on_left(const Point& q) const { return dir.cross(q - p) > -EPS; }
  Point intersect(const Line& o) const {
    long double t = (o.p - p).cross(o.dir) / dir.cross(o.dir);
    return p + dir * t;
  }
};

vector<Point> half_plane_intersection(vector<Line>& lines) {
  sort(lines.begin(), lines.end(), [](const Line& a, const Line& b) {
    return a.angle < b.angle;
  });

  deque<Line> dq;
  for (auto& l : lines) {
    if (!dq.empty() && abs(dq.back().angle - l.angle) < EPS) {
      if (dq.back().on_left(l.p)) dq.pop_back();
      else continue;
    }
    while (dq.size() >= 2 && !l.on_left(dq.back().intersect(dq[dq.size() - 2]))) {
      dq.pop_back();
    }
    while (dq.size() >= 2 && !l.on_left(dq.front().intersect(dq[1]))) {
      dq.pop_front();
    }
    dq.push_back(l);
  }

  while (dq.size() >= 3 && !dq.front().on_left(dq.back().intersect(dq[dq.size() - 2]))) {
    dq.pop_back();
  }
  while (dq.size() >= 3 && !dq.back().on_left(dq.front().intersect(dq[1]))) {
    dq.pop_front();
  }

  vector<Point> res;
  if (dq.size() < 3) return res;

  for (size_t i = 0; i < dq.size(); i++) {
    res.push_back(dq[i].intersect(dq[(i + 1) % dq.size()]));
  }
  return res;
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  int n;
  while (cin >> n && n != 0) {
    vector<Point> poly(n);
    for (auto& p : poly) cin >> p.x >> p.y;

    vector<Line> lines;
    lines.emplace_back(Point{-10000, -10000}, Point{1, 0});
    lines.emplace_back(Point{10000, -10000}, Point{0, 1});
    lines.emplace_back(Point{10000, 10000}, Point{-1, 0});
    lines.emplace_back(Point{-10000, 10000}, Point{0, -1});

    for (int i = 0; i < n; i++) {
      Point p1 = poly[i];
      Point p2 = poly[(i + 1) % n];
      lines.emplace_back(p1, p2 - p1);
    }

    if (half_plane_intersection(lines).empty()) cout << "0\n";
    else cout << "1\n";
  }

  return 0;
}